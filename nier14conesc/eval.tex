\section{Current Work and Preliminary Evaluation}
\label{sec:eval}
\lm{High choesion, but components not enough...}

We implemented a translator from \conesc to pure nesC that allows us
to rely on the optimized nesC tool-chain to obtain running
implementations. As for tool support, we are also investigating ways
to automatically generate \conesc skeletons based on graphical
representations of contexts and context groups similar to
Figure~\ref{fig:design}. We are also planning to use the same notation
as input to perform domain-specific static verification, e.g., using
model-checking techniques~\cite{mottolaicse}.

Using the translator, we compare an implementation of the wildlife
monitoring application using our approach against a
functionally-equivalent implementation that would arguably result from
current practice~\cite{programmingsurvey,badgersEWSN}. First, we study
the logical structuring and simplicity of the implementations, which
determine to a great extent the ease of debugging and
maintenance. Next, we study to what extent either approach lends
itself to evolving the software against initially unforeseen
requirements. Finally, we assess the system overhead that our approach
introduces over the current practice, which represents the price to
pay to obtain the advantages it brings.

% \hrule
% \noindent Three key aspects:
% \begin{itemize}
% \item qualitatively compare ConesC and nesC implementations along
%   coupling, dependencies, programmer-visible program states, ...

Our analysis shows that ConesC implementation is much more decoupled as
compared to its nesC counterpart. Since each context represents a situation
the system may find itself in, they are isolated into modules and do not rely
on the internal work of each other or share any global state, which reduces
programmer-visible states. Contrary, in nesC implementation, each situation
is represented by a global state, which should have been taken into account
in every module.

% \item demonstrates that changing the application (for example, adding
%   a new context) is easier in ConesC than nesC;

Changing the application -- adding a new context, for example -- is easier in
ConesC than in nesC. Let us consider, developers want to track a spread of a
disease. To this end, they modify the application, as shown in Fig.~\ref{fig:mwtd},
\ma{I'm not sure we have enough room for this}
by adding a new context~\emph{Carrier} to mark an animal that have been in
contact with diseased one, but shows no increase in temperature yet. In
ConesC-written implementation it is necessary to make changes in 5 lines and
to add a new module -- \emph{Carrier} context -- while the number of
programmer-visible states remains the same. In nesC counterpart, however,
developers need to modify 8 lines of code, which also leads to 2 additional
global states of the program.


% \item shows a few figures on run-time overhead to demonstrate the
%   approach is feasible.
% \end{itemize}

ConeC approach in our scenario shows a CPU-overhead up to 3 cycles for calls of
a layered function and up to 20 CPU-cycles for context transitions, depending on
the number of contexts in a context group, where the function and contexts are
declared. These numbers are negligible in terms of energy consumption, since the
simplest operation, like enabling/disabling LED, uses 8 CPU-cycles.

\hrule
The results we present hereafter are based on a TMote
Sky~\cite{} platform, a wireless sensor node featuring a TI MSP430 MCU
with 8KBytes of RAM and a low-power CC2420 radio.
\hrule

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "paper"
%%% End: 
