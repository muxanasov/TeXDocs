\section{Programming Support}
\label{sec:conesc}

We render the design concepts above in a set of context-oriented
programming (COP)~\cite{Hirschfeld08} constructs feasible within
existing programming environments for resource-constrained CPS
platforms~\cite{mottola10:survey}.  We exemplify our approach based on
nesC~\cite{gay03nesc}, a mainstream sensor network programming
language. However, our approach is not tied to it, and may be readily
translated to other similar programming systems~\cite{mottola10:survey}.

\fakepar{Target language} nesC is an event-driven programming language
for sensor networks, derived from C. Applications are built by
interconnecting \emph{components} that interact by providing or using
\emph{interfaces}. An interface lists one or more functions, tagged as
\emph{commands} or \emph{events}. % Commands are used to execute
% actions, while events are used to collect the results
% asynchronously.
% Interfaces in nesC are bidirectional: data flows both
% ways between components connected through the same
% interface.
Component \emph{configurations} specify the wirings among
components. % Configurations are component themselves, so they can offer
% interfaces and be wired to other components.

nesC exemplifies the limitations dictated by the target platforms, and
hence the reasons why existing COP approaches cannot be directly
ported. Because of the limited memory available, for example,
components cannot be instantiated at run-time. They are rather
in-lined at compile time so to reduce the size of the executable
binary~\cite{gay03nesc}, which would hardly fit in the available
program memory otherwise.  The use of dynamically-allocated memory is
also discouraged: the MCUs provide no memory protection, so bugs in
memory handling may have disastrous effects.

\fakepar{\conesc} Notwithstanding the above constraints, we design a
context-oriented extension to nesC, called \conesc, that incorporates
the design concepts described in Section~\ref{sec:design}. 

At the core of \conesc is a notion of \emph{layered
  function}~\cite{Hirschfeld08}. These are functions whose behavior
depends on the currently active context, and are hence the primary
means to implement the behavioral variations necessary for
self-adaptation. A \emph{context group} in \conesc extends standard
nesC configurations by also specifying the contexts included in the
group and the layered functions that such contexts provide. The
individual contexts extend the nesC component providing the
context-dependent implementations of layered functions.

\begin{figure}[!tb]
\begin{lstlisting}[style=conescframe]
context group BaseStationG {
*\lstnote{cg:layered}* layered command void report(contact_t contact);
}implementation {
*\lstnote{cg:ctx}* contexts Reachable, 
*\lstnote{cg:def}*          Unreachable is default,
*\lstnote{cg:error}*          ErrorC is error;
 // Standard nesC component wirings... }
\end{lstlisting}
\vspace{-5mm}
\caption{Context group in \conesc.}
  \label{fig:configuration}
\vspace{-3mm}
\end{figure}

Figure~\ref{fig:configuration} depicts a snippet of \conesc code to
implement the ``Base Station'' group in Figure~\ref{fig:design}. In
this example, the \code{report()} command on
line~\lstref{cg:layered}---used to report a contact with another animal
to the end-user---changes the behavior depending on whether the
base-station is \code{Reachable} or \code{Unreachable}. The latter are
the contexts included in this group, specified on line~\lstref{cg:ctx}
after the keyword \code{contexts} with optional modifiers: \code{is
  default} (line~\lstref{cg:def}) specifies the active context at
start-up, and \code{is error} (line~\lstref{cg:error}) indicates an
error context. The latter is automatically activated should there be
violations to constraints defined over context transitions, e.g., the
fact that ``Resting'' or ``NotMoving'' must be active when
transitioning from ``Healthy'' to ``Diseased'', as shown in
Figure~\ref{fig:design}.

\begin{figure}[!tb]
\begin{lstlisting}[style=conescframe]
context Reachable {
*\lstnote{ct:tr}* transitions Unreachable;
*\lstnote{ct:trigger}* triggers NotMoving;
 uses interface Radio;
} implementation {
*\lstnote{ct:layer}* layered command void report(contact_t contact){
  call Radio.send(contact);}}
*\lstnote{ct:activate}* event void activated(){// Dump logs on base-station }
*\lstnote{ct:deactivate}* event void deactivated(){ // Radio clean-up }
\end{lstlisting}
\vspace{-5mm}
\caption{Individual context in \conesc.}
  \label{fig:context}
\vspace{-5mm}
\end{figure}

Figure~\ref{fig:context} shows the \conesc specification of the
``Reachable'' context. The keyword \code{transitions} on
line~\lstref{ct:tr} specifies the allowed outgoing transitions, whereas
the keyword \code{triggers} on line~\lstref{ct:trigger} is available
to bind context activations across groups. In this case, entering the
``Unreachable'' context consequently activates ``NotMoving'', as
specified in Figure~\ref{fig:design}. The specific implementation of
the layered function is indicated on line~\lstref{ct:layer} with the
\code{layered} keyword.  The implementation of other commands or
events is as in standard nesC. Particularly, the predefined events
\code{activated()} and \code{deactivated()}, shown on
lines~\lstref{ct:activate} and~\lstref{ct:deactivate}, are
automatically signalled when entering and existing the context,
allowing the implementation of one-time operations and the
starting/stopping of continuous activities in a context.

The contexts indicated after the \code{transitions} keyword inside
individual contexts are possibly followed by the \code{iff} keyword to
state constraints on the transitions, as in
\begin{lstlisting}[language=conesc]
transitions Diseased iff Resting || NotMoving;
\end{lstlisting}
used in the definition of the ``Healthy'' context to encode the
constraints in Figure~\ref{fig:design}. If such a transition is
attempted at run-time, but the constraints are violated, the error
context defined in the corresponding context group is activated. 

Explicit context activation may happen anywhere in the code, using the
\code{activate} keyword, as in
\begin{lstlisting}[language=conesc]
activate BaseStationG.Unreachable;
\end{lstlisting}
This enables complete decoupling between the context-de\-pen\-dent
application logic---confined within the layered functions inside the
individual contexts---and the adaptation logic itself, which may be
specified in a separate component. Such feature helps separate
orthogonal concerns and hence facilitates testing, maintenance,
and evolution of the software, as we discuss next.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "paper"
%%% End: 
