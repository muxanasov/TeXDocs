\section{Related Work}
\label{sec:related}

Efforts close to ours particularly address the design and
implementation of self-adaptive embedded system software,
context-oriented programming, and system-level adaptiveness in
CPSs. We briefly survey paradigmatic examples.

Works in self-adaptive embedded system software
spans phases from requirement engineering to
verification~\cite{cheng:adaptive}. Co-design approaches also exist
where the hardware/software boundaries blur for greater
flexibility~\cite{diguet11:closed}. Unlike in our work, several of
these solutions focus on a few environmental dimensions, each
requiring ad-hoc self-adaptive functionality. In our target
applications, complexity arises especially from the 
combinations that multiple environmental dimensions concurrently
generate. Nevertheless, most of these solutions would be hardly
applicable in resource-constrained CPSs, due to
run-time overhead.

Villegas~\cite{VilegasPhD13} designed dedicated software support for
situation-aware software systems. Despite sharing some high-level
challenges with our work, Villegas relies on the end-user as a
controller of context management, whereas we focus on autonomous
systems. Moreover, we directly deal with physical sensors to acquire
context information, whereas these are abstracted in software-based
sensor devices in Villega's work.

% e.g. adaptivity and context representation and management -- are
% addressed in the work, the motivating example and consequent reasoning
% are base on user-centric self-adaptive software systems. The latter
% implies the end-user as a controller of the context management, while
% we are focused on the systems which are governed by themselves, or by
% the programmer, at least. The proposed in~\cite{VilegasPhD11} context
% ontology, context control model and reference model are not
% considering application scenarios of CPSs, and, thus, are not
% applicable. Differently, our research is based on particular
% challenges arose when creating adaptive software for CPSs. Besides, we
% are using physical sensor devices and considering all the consequent
% challenges to derive the context, while Villegas
% N.~\cite{VilegasPhD11} is considering software-based \emph{sensor} to
% monitor software service interface.

Fleurey et al.~\cite{Fleureya-adaptive-firmwares11} present a
model-driven approach for creating adaptive firmwares. They model the
application as a single state machine and define behavioral variations
based on predicates defined over the application state. When such
predicates are found true, the system accordingly adapt the state
machine transitions. Code is automatically generated from these
specifications. Compared to this effort, we do not target completely
automatic code generation, but provide dedicated programming
constructs. This offers greater freedom in encoding the conditions to
trigger context changes and enables finer-grained optimizations, which
may be mandatory given the resource limitations. Moreover, we seek to
integrate our approach in existing component-based CPS frameworks,
leveraging the existing code base.

The COP model~\cite{Hirschfeld08} is implemented in several high-level
languages~\cite{Bardram05,Ghezzi10,Kamina11,Salvaneschi12,Sehic11}. These
are, however, generally unfeasible on the platforms we target. We
borrow a few of these concepts---for example, our layered functions in
context groups are akin to the concept of
layer-in-class~\cite{Salvaneschi12}---and adapt them to the
limitations of component-based frameworks for resource-constrained
CPSs. In this area, the embedded devices are rather seen as
application-agnostic providers of raw sensor
data~\cite{Sehic11}. Differently, we bring COP down to the
component-based CPS software, enabling self-adaptive functionality
right on the devices that directly interact with the environment.

Aside from COP, Meta- and Aspect-oriented Programming (AOP) offer
programming support to implement adaptive
functionality~\cite{SalvaneschiTBP}. The former requires
self-modification of the binary, which is often unfeasible in
resource-constrained CPSs. Similar requirements hold for
AOP~\cite{Kiczales:AOP:97}, which is often applied to large and
complex software projects. Arguably, applying AOP to the relative
simple processing running aboard the CPS devices, even if possible,
would be quite overkill. Moreover, general agreement is that COP
offers the best support for modularization~\cite{SalvaneschiTBP}. This
feature is fundamental to embed programming support for
self-adaptation within existing component-based frameworks.

% was introduced to handle the
% crosscutting in concerns of software. Each software has a number of
% orthogonal functionality -- e.g. concerns -- which might intersect
% each other in some parts of the
% source-code~\cite{Tarr:concerns:99}. To keep modularization and
% maintainability, AOP allows to separate these parts into the
% \emph{aspects}, and, thus, to save the separation between
% concerns. COP, however, focuses on the representation of alternative
% behavior, by using notion of \emph{layers} and separating the
% implementations of behavioral variations.  Thus, the separation into
% aspects is no more needed. Moreover, among the other mentioned
% techniques, COP yields programs with the lowest
% complexity~\cite{SalvaneschiTBP}.

Specific cases of run-time adaptation are seen at system level in the
CPS literature. For example, Zimmerling et al.~\cite{zimmerling12}
focus on run-time reconfiguration of MAC protocol parameters depending
on environmental conditions. Routing protocols expressly designed with
self-adaptive functionality also exist~\cite{Bourdenas11}. Such
efforts essentially address a complementary problem. While we aim to
provide design-time and programming support to implement self-adaptive
software in this domain, these works focus on the actual
problem-specific adaptation logic.

% There are some attempts to apply context-oriented programming for the software
% for CPSs. Sehic et al.~\cite{Sehic11}, for example, proposed a macro-language
% for rapid development of context-aware applications for CPSs. Wood et
% al.~\cite{Wood08} developed a CPS for Assisted-Living and Residential
% Monitoring, which utilizes a technique of a context-depended behavior. Another
% work, provided by Ghezzi et al.~\cite{}, is devoted to the language
% support for bringing a context-awareness for CPSs.

% Several attempts were also performed towards self-adaptive software for CPSs. In
% the work of Steine et al.~\cite{Steine11} authors were focused on run-time
% reconfiguration of WSNs by adjusting protocol values dynamically depending on
% the conditions the system operates in. Marques et al.~\cite{Marques11} propose a
% run-time evaluation of QoS characteristics for better adaptation. Another
% research was provided towards self-adaptive protocols: MAC-protocol by Park et
% al.~\cite{Park08} and routing protocol by Bourdenas et al.~\cite{Bourdenas11}.
% Self-adaptivity is also considered as a main ingredient of run-time error
% handling~\cite{Bourdenas10} and energy management~\cite{Jiang07}.

% Despite the research activity in the area of self-adaptive software for CPSs is
% quite intensive, it remains fragmented, and no holistic approach yet developed.
% Current research has two extreme directions:~\emph{i)} high-level software,
% which brings adaptivity only in application level using CPSs as raw-data
% providers~\cite{Wood08,Sehic11,Ghezzi10}, and~\emph{ii)} low-level software,
% which is focused on a system level ignoring an application
% level~\cite{Steine11,Marques11,Park08,Bourdenas11,Bourdenas10,Jiang07}.
% We combine different aspects of self-adaptivity for CPSs and provide robust
% approach for self-adaptivity on both system and application levels, which makes
% our work novel in this field.

% Salvaneschi et al.~\cite{SalvaneschiTBP}\footnote{to be published}\cite{Salvaneschi12} 
% outlined possible techniques for language adaptation for context-oriented
% programming. We not only utilize concepts of COP, but also provide a novel approach for
% bringing context-oriented programming to CPSs. To this end, we modified and
% applied such techniques as: \emph{Per-Object activation} and
% \emph{Layer-in-Class} \cite{Salvaneschi12}. The latter implies the
% implementations of layers~\cite{Costanza05} -- i.e. behavioral variations -- in
% one class. In our approach we used \emph{context groups} to aggregate behavioral
% variations, which are invoked by explicit activation of corresponding
% \emph{context}, i.e. we adopted \emph{Per-Object activation}, where an
% \emph{object} is a~\emph{context}.


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "paper"
%%% End: 
