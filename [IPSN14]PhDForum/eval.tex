\section{Evaluation}\label{sec:eval}

For evaluation purposes, we implemented three applications. For each we compare
nesC implementation against its \conesc counterpart.

{\bf Complexity} is estimated by using such metrics as the number of lines of
code (LOC), the number of variables declared and functions
defined~\cite{Pressman01}. Despite our results show 30\% increase of average
complexity, there is significant reduction in average per-module complexity --
-54\%. We believe that in larger applications the number of the similar lines of
code will be bigger. Nevertheless, \conesc-written applicaton is more than 3
times smaller than generated code, what makes \conesc an effective tool for
context-oriented programming.

{\bf Overhead} in terms of memory is lesser than
2,5\% for binary size and less than 4,5\% for RAM overhead. The average CPU
overhead for layered function calls oscillates from 2 to 5 CPU cycles depending
on application, which is negligible in terms of energy consumption, since the
simplest operation in TinyOS -- turn on/off LEDs -- consumes 8 CPU cycles. The
context transitions overhead is bigger -- from 10 to 25 CPU cycles -- but
remains in the same order of magnitude.
