% =============================================================================
\section{ConesC}
% =============================================================================
We describe next the concepts and programming model of \conesc, along
with a brief report of ongoing work and preliminary results.

\subsection{Concepts}

Programming in \conesc revolves around two key concepts: \emph{i)}
context groups, and \emph{ii)} individual contexts and their
transitions. The latter represent the different environment situations
a system may find itself in. Each context maps to a different
application-level or system-level processing. As the environment
surrounding the system mutates, programmer triggers transitions from a
context to a different one by \emph{activating} a given
context. Context groups, on the other hand, represent collections of
individual contexts sharing common characteristics; for example,
whenever transitions among the involved contexts are determined by
changes in the same physical quantity.

\input{code_snippets}

Figure~\ref{fig:cdsm} shows how a design of the example health-care
application maps to these concepts. At application level, the
\emph{health condition} context group includes three individual
contexts representing a person's possible health conditions. In this
example design, we deploy heart rate and acceleration sensors to
determine a person's health conditions. Starting from \emph{normal}
conditions, a grow in heart rate may indicate a possible
\emph{emergency} if the person is not moving, or simply the he/she is
\emph{exercising} should the acceleration sensor record significant
movements.

At system level, the \emph{location} context group
includes two individual contexts representing whether a person's
device is \emph{indoor}, where the system can rely on some
infrastructure to funnel data to a back-end, or rather \emph{outdoor},
where no infrastructure is available. We can design transitions
between these individual contexts as a function of periodic beacons
received from the infrastructure.

As we describe next, the organization of context information in
context groups and individual contexts is useful as a foundation for
programming with \conesc. Moreover, it may also serve for
automatically generating code skeletons and for statically verifying
the possible system executions against safety or liveness properties,
e.g., using model-checking techniques. We plan to explore these
opportunities in the near future.

\subsection{Programming Model and Language}

We build upon nesC, a widespread sensor network programming
language~\cite{gay03:nesc}. NesC itself extends the C language by
providing component-based programming and a notion of split-phase
execution of functions to address the WSN highly concurrent processing
and the devices' resource constraints. In nesC, \emph{commands} are
function calls that return immediately. The results of the
corresponding operations, if any, is returned by means of asynchronous
\emph{events}.

We design additional language constructs for nesC to map the notions
of context groups, individual contexts, and transitions among
them. Context groups map to \emph{context configurations}. These
extend the traditional nesC configuration by specifying, in addition
to the wiring among components, the necessary layered
functions---being commands or events---and the individual contexts
that provide context-specific implementations for such functions.

Figure~\ref{fig:ccc} shows an example context configuration in
\conesc, corresponding to the location context group of
Figure~\ref{fig:cdsm}. We define a layered {\textlst{report}} command
(line \lstref{layereddef}) that abstractly specifies the processing to
report sensed data, and whose concrete implementation is delegated to
the individual contexts. The individual contexts belonging to the
group are declared with the keyword {\textlst{contexts}} (line
\lstref{contexts}), including a tag {\textlst{is default}} to indicate
the context to activate after initialization. Moreover, each context
group has an {\textlst{Error}} context, which is activated if illegal
context transitions are triggered, as we describe next. The
implementation of layered functions for the {\textlst{Error}} context
is automatically generated by the \conesc tool-chain, but programmers can
redefine it if necessary. The remainder of the context configuration
specifies the components used and their wiring using standard nesC
syntax.

\input{code_snippets2}

The individual contexts map to \emph{context modules}. These extend
normal nesC modules by additionally specifying the outgoing
transitions from an individual context, the context-specific
implementation of layered functions, and additional support functions
to check whether the execution is allowed to activate the context and
to perform operations when activating/deactivating the context.

Figure~\ref{fig:cc} shows the context module for the individual
{\textlst{Indoor}} context of Figure~\ref{fig:cdsm}. Outgoing
transitions from this context are defined with the
{\textlst{transitions}} keyword (line \lstref{transitions}): if the
execution activates a context where no outgoing transition from the
current context exists, the execution moves to the {\textlst{Error}}
context in the pertaining context configuration, as in
Figure~\ref{fig:ccc}. If transitions are not defined, any transition
is legal. By implementing events {\textlst{activate}} (line
\lstref{activated}) and {\textlst{deactivate}} (line
\lstref{deactivated}), programmers can optionally specify
initialization and clean-up functionality for the
context. Nevertheless, if the transition to this context is legal,
before activating it the system executes the {\textlst{check}} command
(line \lstref{check}). An individual context's implementation can use
{\textlst{check}} to signal, for example, whether it is ready to be
activated. If {\textlst{FALSE}} is returned, the currently active
context remains unchanged.

The key to realize context-dependent functionality is in the
implementation and use of layered functions. In the example of
Figure~\ref{fig:cc}---corresponding to the {\textlst{Indoor}}
context---the implementation of the layered command {\textlst{report}}
(line \lstref{layeredimp}) relies on a collection protocol to
immediately relay the data to the back end, as an infrastructure is
available when indoor. Code relying on the {\textlst{report}}
functionality, for example in a periodic loop, can be written in a
generic manner w.r.t.\ what specific implementation is to be used, as
exemplified in Figure~\ref{fig:ue}. The underlying run-time support
takes care of dispatching the call to the implementation of the
currently active context. The latter is determined at run-time with
the {\textlst{activate}} keyword, also shown in Figure~\ref{fig:ue}.

\subsection{Ongoing Work and Early Results}

We are implementing the tool-chain in support to \conesc. We designed
translation rules from \conesc to pure nesC, and are implementing such
rules using XXX. Meanwhile, we are assessing the effectiveness of
\conesc using hand-written examples, looking at how simpler is the
implementation of context-dependent functionality against processing
and memory overhead. Our analysis targets the TelosB platform and
considers nesC as a baseline, because it is both a widespread sensor
network language and the target language of our tool-chain. For
example, a comparison of a simplified version of the
{\textlst{Location}} context configuration and its constituents
individual contexts demonstrates that the compiled binaries grow by
only 2\% using \conesc, and yet the code is way more decoupled, which
fosters simpler maintenance, as well as significantly easier to read
and to debug.


% In {\textlst{ConesC}} we divided contexts into \emph{context groups}. Each \emph{context group} consists of contexts which could be logically combined. For example, contexts, which are representing the information with the same type, could be integrated into one \emph{context group}. It brings COP on a new level of abstraction and makes it possible to operate complex structures of contexts as an integration of smaller substructures. Thus, every WSNs could have several mostly independent \emph{context groups}. Context transitions within the group are initiated by \emph{triggers} and can be performed only if particular conditions are satisfied. There are also actions which should be performed before activation and after deactivation of the context.

% Figure \ref{fig:cdsm} utilises our concepts of {\textlst{ConesC}} and represents a structure of contexts for Health-Care System. We can find two groups of contexts in this application: \textit{Location} group and \textit{Health conditions} group.

% \paragraph{Location.} While user is within the house, nodes, which attached to the user, have a mostly stable connection with the infrastructure and can send data directly to it. If user is outside, nodes should collect the information.

% \paragraph{Health conditions.} Independently on the data collection, nodes also should monitor the readings to detect emergency situations. In our example, if userâ€™s heart rate (HR) is above threshold (T), it could be treated as a heart attack. But it also could mean that he does exercise. In other case, emergency situation can also happen during exercises.


% \textbf{Context configuration} component represents a context group (figure \ref{fig:ccc}). It is used to declare \emph{layered functions} and contexts included in the group. The behaviour of the layered function (line \lstref{layereddef}) depends on activated context within the current group. Declared functions should be implemented in each declared context. 

% On the line \lstref{layeredimp} there is an implementation of the layered function. By calling layered function system choose a specific implementation of that function for the activated context. The implementation is mandatory if the function is declared in the {\textlst{context configuration}}.

% The context transition could be triggered by the key-word {\textlst{activate}}. In our example (figure \ref{fig:ue}) this key-word triggers the context transition from the current activated context to the context {\textlst{High}}. Then by calling function {\textlst{Temperature.toggle\_leds()}} system will call the function which was implemented within the context {\textlst{High}}.

% Since {\textlst{ConesC}} is based on {\textlst{nesC}} it is necessary to compare them. To do this we implemented two applications for {\textlst{telosB}} platform. These applications have the same functionality: it toggles light on the T-Mote depending on the temperature. One of these applications was implemented using {\textlst{nesC}}, while another was implemented using {\textlst{ConesC}}. Binaries of programs differ by only 2\%: 7758 bytes for {\textlst{ConesC}} vs 7640 bytes for {\textlst{nesC}}.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "ubicomp"
%%% End: 
