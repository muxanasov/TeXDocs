\section{Conclusion}\label{sec:ending}

We presented programming abstractions for implementing adaptive WSN software. By
borrowing COP concepts, we brought the adaptive software down to low-level
system programming, and introduced a set of language independent concepts,
described in Sec.~\ref{sec:appdesign}. These concepts found their place in our
own context-oriented extension of nesC, called \conesc. To transform \conesc to
plan nesC code, we developed a dedicated translator, described in
Sec.~\ref{sec:translator}.

As we observed in~\ref{sec:eval} based on three representative applications,
\conesc simplifies the developing for WSNs. We shown that along with decoupling
of software components, we gain also a $\approx$50\% reduction in the number of
per-function states that programmers need to deal with. Moreover, due to
decoupled modular structure, \conesc applications can be evolved with lesser
efforts as compared to their nesC counterparts. The price is, however,
negligible: we observed the overhead in memory (data) of maximum 2.5\% (4.5\%),
while the maximum of MCU overhead for context transition (function call) is only
28 (4) MCU cycles.

To our knowledge, efforts related to ours can be divided into WSN-specific
adaptation and programmer support for adaptation outside WSN. Meanwhile, \conesc
brings the design-time programming support for adaptive low-level WSN software.

% use section* for acknowledgement
%\section*{Acknowledgment}
%The authors would like to thank...