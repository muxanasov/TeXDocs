\input{snippets}
\section{Context Oriented nesC (ConesC)}\label{sec:conesc}

\conesc provides a design-time support for developing a self-adaptive software,
which alternates its behavior at run-time including catching and handling
errors. Along with this, our approach provides a deep modularization, since
behavioral variations are encapsulated into different modules. The latter, as we
show in Sec.~\ref{sec:evalcomp}, are highly decoupled, which enhances code
readability and re-usability as well as debugging and developing processes.

Programming in \conesc is intimately tied with environment-dependent behavior of
the application and exploits two main concepts: \emph{i)} individual contexts
and their transitions and \emph{ii)} context groups. The former represent
different environment situations where a system may find itself. Each context
maps to a separate state of the device or environment a system operates in. As
the environment conditions change, a programmer initiates a context transition
by \emph{activating} the corresponding context. A context group is a set of
contexts sharing common characteristics and variations of the same
functionality. Thus, whenever a transition between involved contexts occurs, it
is determined by changes in one or more physical quantities.

\subsection{Application design}\label{sec:appdesign}

The diagram on Fig.~\ref{fig:wtd} shows how these concepts are used in the
design of application. By using a body temperature sensor system detects if an
animal is \emph{Diseased} and builds an alert beacon or a normal beacon
otherwise. Here contexts \emph{Healthy} and \emph{Deiseased} are based on a
physical quantity -- the body temperature of an animal -- and reflect variations
of the same functionality, such as building a beacon, so they can be joined into
a group \emph{Health conditions}.

Depending on GPS readings developers may want to vary a sampling rate to use
energy more effective. For example, there is no need to track a location if an
animal is \emph{NotMoving}, but should accelerometer detect any significant
movement, a periodic sampling should be initiated. Increased difference between
two location readings indicates that an animal is \emph{Running}, and location
sampling should occurs more often.

Orthogonal to application-level functionality, the system should transmit data
to the Base Station (BS) or save readings locally depending on the BS
availability. Whenever the latter is \emph{Unreachable}, a node logs data in
internal memory, but should it receive a BS-beacon, the data is dumped to the
BS. Crucially, the node runs on a battery, so the system should be aware of a
battery status and disable GPS-module, which is power consuming, if the battery
level is \emph{Low}.

\conesc reflects this design by using new types of components, such as
\emph{context} and \emph{context group} -- extensions of \emph{module} and
\emph{configuration} correspondingly -- and a set of new key-words. Instances of
new types, however, can also be used as standard nesC components, e.g. they can
provide or use interfaces as well as be declared in the same way.

\putfigure{caption=Wildlife tracking diagram.,label=fig:wtd}{
 \centering
 \includegraphics[width=\columnwidth]{pdf/wildlifetracking}
}

\subsection{Contexts and Context Groups}\label{subsec:components}

The \emph{Context group} component is displayed on Fig.~\ref{fig:ccc} and used
to declare layered functions and the contexts included. The former is declared
on line~\lstref{layereddef} by using the key-word \emph{layered}, while the
declaration of the latter starts from the key-word \emph{contexts} on
line~\lstref{contexts}. The mandatory modifier \emph{is default} indicates an
active at start-up context, as shown on line~\lstref{isdefault}. Another
modifier on the the next line~\lstref{iserror} declares the context
\emph{ErrorC} as an \emph{error} context, which is used to handle errors
occurred during the execution, it is optional though. If an \emph{error} context
is not declared, it will be generated automatically. We discuss the use of this
context in section~\ref{subsec:rules}.

\putsnippet{
 caption=Context configuration component.,
 label=fig:ccc,
 boxname=boxcc
}

Figures~\ref{fig:cc} and~\ref{fig:irc} display \emph{Context} components, main
purpose of which is an implementation of layered function declared in context configuration. 
This approach enables a behavioral variation, since the implementation of a layered function is
context-specific, and only one context within the group can be active at a time. Thus, in our
example, a behavior of the function \emph{report()} depends on the activated context and
deposits a message in local memory, while \emph{Unreachable} context
is active (figure~\ref{fig:cc}, line~\lstref{layeredimp}),
or sends it directly to the BS otherwise (figure~\ref{fig:irc}, line~\lstref{layeredimp2}).
Developer may want to add some instructions after
context activation such as initialization of variables or enabling/disabling
modules, as in our example in Fig.~\ref{fig:wtd} we enable GPS-sensor on entering
in \emph{Unreachable} context. Or it may be necessary to reset component's state before context
deactivation. To this end ConesC provides events \emph{activated()} and
\emph{deactivated()} correspondingly, whose stub implementation is shown on
lines~\lstref{activated} and~\lstref{deactivated} in Fig.~\ref{fig:cc}. The implementation of
these events, however, is not obligatory.

\putsnippet{
 caption=Context component.,
 label=fig:cc,
 boxname=boxc
}

\subsection{Usage}

This section shows how ConesC can be used to invoke a behavioral
variation. Here we describe one aspect of an application's behavioral variation,
which is related to the Base Station availability. As it was mentioned before,
if a node receives a beacon from the Base Station it activates the \emph{Reachable}
context, and the \emph{Unreachable} context in case of timeout.
Since the behavioral variation is encapsulated in a context group \emph{BaseStationG},
a developer may not care about the context implementation and use a context group
to change a behavior of the application at run-time. Fig.~\ref{fig:mc} depicts the main
configuration, where the base station group is declared on line~\lstref{declaration} and wired
as a standard component afterward on the line~\lstref{wiring}.

\putsnippet{
 caption=Main configuration.,
 label=fig:mc,
 boxname=boxmc
}

In the main module, which is displayed in Fig.~\ref{fig:mm}, it is necessary to declare
explicitly that the context group \emph{BaseStationG} is used, as shown on the line~\lstref{cgdecl}.
At run-time, however, developers should not care about the base station availability, while
reporting measured data, since the behavior of layered function
\emph{BaseStationG.report()} -- on the line~\lstref{calling} -- depends on activated
context, i.e. the base station availability. The benefit of
this approach is that layered function can be called independently, and activating code
can be kept isolated, even in a separate module, which is displayed in Fig.~\ref{fig:bscm}.
Activation of a context initiates by using the key-word
\emph{activate} which is followed by a full context name. Thus,
\emph{Reachable} context is activated on the line~\lstref{actBS} as soon as a
beacon from the base station is received. But should timeout occur, context
\emph{Unreachable} is activated on the line~\lstref{actNoBS}.

\putsnippet{
 caption=Main module.,
 label=fig:mm,
 boxname=boxmm
}

\putsnippet{
 caption=Base station context manager.,
 label=fig:bscm,
 boxname=boxbscm
}

Every time the context changed, an event~\emph{contextChanged()} is fired. This event can be
caught and handled, as it is shown on the line~\lstref{eventCC} in Fig.~\ref{fig:mm},
but it is not mandatory though. Context in this scope is considered as a constant,
whose name consists of two parts, joined by a dot: a name of a group and a name
of a context. Thus, in function \emph{BaseStationG.contextChanged()} we can use
a passed parameter \emph{con} to find out what context has been activated, as
shown on the line~\lstref{concheck}.

\subsection{Transition rules}\label{subsec:rules}

In ConesC every context transition implies several checking stages, which are displayed in
Fig.~\ref{fig:ad}, such as: possibility of the transition, dependencies check and conditions
check. The successful check allows to continue a transition, while the failure leads either to
the canceling of the transition or to activation of the \emph{error} context. The latter is generated
automatically unless declared in a \emph{context group} by using the key-word \emph{is error},
as shown in Fig.~\ref{fig:ccc} on line~\lstref{iserror}.

\putfigure{ caption=Activation diagram.,label=fig:ad}{
 \centering
 \includegraphics[width=\columnwidth]{pdf/activation_diagram}
}

In our scenario, which is displayed on a figure~\ref{fig:wtd}, within \emph{Activity} group a
transition from \emph{NotMoving} to \emph{Resting} is only possible, and it is checked
by the first conditional chose displayed on a figure~\ref{fig:ad}.
Since each transition is governed by a separate rule, it is declared in a context component as shown
on line~\lstref{transitions} in figure~\ref{fig:nmc}. Here key-word \emph{transitions}
indicates the contexts a transition can be performed to. An attempt to initiate
a transition to the context, which is not declared in a given active context, leads to an error context
activation, since this kind of transitions is not possible.

\putsnippet{
 caption=NotMoving context.,
 label=fig:nmc,
 boxname=boxnmc
}

Despite the application's  functionality is split into isolated pieces by \emph{context groups},
there may exist relations among them. For example, within the 
\emph{Health conditions} group a transition from \emph{Healthy} to \emph{Diseased} is only
make sense if an animal is \emph{Resting} or \emph{NotMoving}. These inter-group
relations are covered in our context-oriented language by context dependencies,
which are checked in the second conditional chose on a figure~\ref{fig:ad}. In
ConesC dependencies are declared as it is shown on the line~\lstref{dependence}
in Fig.~\ref{fig:cc}. In \emph{transitions} section a context name followed by a
key-word \emph{iff} and a full name of another context means that
the transition will only be executed if the latter context is active. Should the
rule with dependency be violated, a transition to an error context will be triggered.

The last conditional chose displayed on a figure~\ref{fig:ad} is used for soft rules, violation of
which does not affect the execution of a program. For example, context~\emph{Running} is
activated if the difference between two GPS readings is relatively large, but it may be due to noise.
To make sure false positives are avoided, developers may want to check
readings of an accelerometer. Another example includes an energy saving scenario,
when a programmer may want to activate~\emph{Reachable} context only if a battery is
in~\emph{Normal} state, as shown in Fig.~\ref{fig:wtd}.
Violation of mentioned rules is a common situation and should not lead to an error state.
To this end, ConesC provides a \emph{check()} command, sample implementation of which is
displayed on the line~\lstref{check} in Fig.~\ref{fig:irc}. It is not mandatory to implement this
command, but should it return \emph{FALSE}, an initiated context transition does not occur,
a context is not activated and a system remains in the previous state.
This approach allows one not to think about conditions a transition taking
place in, but foresee possible inconsistencies.

\putsnippet{
 caption=Reachable context.,
 label=fig:irc,
 boxname=boxirc
}

Other types of inter-group relations imply automatic triggering of context
transition. Considering \emph{Battery} group in our example, we can notice that
for further energy saving developers may want to trigger a transition to
\emph{Unreachable} context within the \emph{Base Station} group as long as
\emph{Low} context is active. Our design allows one to do that by declaring a
\emph{triggers} section, as shown on the line~\lstref{triggers} in Fig.~\ref{fig:lc}.
The same checks apply to automatic transitions.

\putsnippet{
 caption=Low context.,
 label=fig:lc,
 boxname=boxlc
}
