\input{snippets}
\section{ConesC}\label{sec:conesc}

% \conesc provides a design-time support for developing a self-adaptive software,
% which alternates its behavior at run-time including catching and handling
% errors. Along with this, our approach provides a deep modularization, since
% behavioral variations are encapsulated into different modules. The latter, as we
% show in Sec.~\ref{sec:evalcomp}, are highly decoupled, which enhances code
% readability and re-usability as well as debugging and developing processes.

We illustrate how we render the concepts in
Section~\ref{sec:appdesign} within \conesc: our own context-oriented
extension to nesC.  We describe a notion of context module and
configuration in Section~\ref{subsec:components}, and discuss in
Section~\ref{subsec:usage} how programmers use these constructs to
specify an application's adaptive behavior.
Section~\ref{subsec:usage} describes how \conesc programmers may deal
with unforeseen context evolutions.

\subsection{Contexts and Context Groups}\label{subsec:components}

\putsnippet{
 caption=Context group in \conesc.,
 label=fig:ccc,
 boxname=boxcc
}

Context groups in \conesc extend the standard nesC
configurations. Programmers use context groups to to declare layered
functions and the contexts providing the corresponding behavioral
variations depending on the situation. 

Fig.~\ref{fig:ccc} shows an example for the \emph{Base-station}
group. A layered \code{report} function is declared on
line~\lstref{layereddef} by using the keyword \code{layered}. The
contexts providing the necessary behavioral variations are specified
following the keyword \code{contexts} on line~\lstref{contexts}. In
this case, programmers define two such contexts, depending on
base-station reachability. The \code{is default} modifier, shown on
line~\lstref{isdefault} indicates what context is active at
startup. The next \code{is error} modifier on line~\lstref{iserror}
declares context \code{ErrorC} as an \emph{error} context, which
programmers may optionally use to handle errors during the execution,
as we discuss in Section~\ref{subsec:rules}. If an error context is
not declared, it is generated automatically.

\putsnippet{
 caption=\emph{Reachable} context.,
 label=fig:irc,
 boxname=boxirc
}

\putsnippet{
 caption=\emph{Unreachable} context.,
 label=fig:cc,
 boxname=boxc
}

The individual contexts in \conesc extend the standard nesC modules by
providing context-dependent implementations of layered function
declared in context groups. Only one context at a time can be
\emph{active} in a group, meaning only one context at a time can
provide the implementation of a given layered function.


For example, Fig.~\ref{fig:irc} and~\ref{fig:cc} show fragments of the
\emph{Reachable} and \emph{Unreachable} contexts referenced in
Fig.~\ref{fig:ccc}. In this example, the behavior of function
\code{report} depends on the activated context and deposits a message
in local memory, while \emph{Unreachable} context is active
(figure~\ref{fig:cc}, line~\lstref{layeredimp}), or sends it directly
to the BS otherwise (figure~\ref{fig:irc}, line~\lstref{layeredimp2}).

Developer may want to add some instructions after context activation
such as initialization of variables or enabling/disabling modules, as
in our example in Fig.~\ref{fig:wtd} we enable GPS-sensor on entering
in \emph{Unreachable} context. Or it may be necessary to reset
component's state before context deactivation. To this end ConesC
provides events \emph{activated()} and \emph{deactivated()}
correspondingly, whose stub implementation is shown on
lines~\lstref{activated} and~\lstref{deactivated} in
Fig.~\ref{fig:cc}. The implementation of these events, however, is not
obligatory.

\subsection{Usage}\label{subsec:usage}

This section shows how ConesC can be used to invoke a behavioral
variation. Here we describe one aspect of an application's behavioral variation,
which is related to the Base Station availability. As it was mentioned before,
if a node receives a beacon from the Base Station it activates the \emph{Reachable}
context, and the \emph{Unreachable} context in case of timeout.
Since the behavioral variation is encapsulated in a context group \emph{BaseStationG},
a developer may not care about the context implementation and use a context group
to change a behavior of the application at run-time. Fig.~\ref{fig:mc} depicts the main
configuration, where the base station group is declared on line~\lstref{declaration} and wired
as a standard component afterward on the line~\lstref{wiring}.

\putsnippet{
 caption=Main configuration.,
 label=fig:mc,
 boxname=boxmc
}

In the main module, which is displayed in Fig.~\ref{fig:mm}, it is necessary to declare
explicitly that the context group \emph{BaseStationG} is used, as shown on the line~\lstref{cgdecl}.
At run-time, however, developers should not care about the base station availability, while
reporting measured data, since the behavior of layered function
\emph{BaseStationG.report()} -- on the line~\lstref{calling} -- depends on activated
context, i.e. the base station availability. The benefit of
this approach is that layered function can be called independently, and activating code
can be kept isolated, even in a separate module, which is displayed in Fig.~\ref{fig:bscm}.
Activation of a context initiates by using the key-word
\emph{activate} which is followed by a full context name. Thus,
\emph{Reachable} context is activated on the line~\lstref{actBS} as soon as a
beacon from the base station is received. But should timeout occur, context
\emph{Unreachable} is activated on the line~\lstref{actNoBS}.

\putsnippet{
 caption=Main module.,
 label=fig:mm,
 boxname=boxmm
}

\putsnippet{
 caption=Base station context manager.,
 label=fig:bscm,
 boxname=boxbscm
}

Every time the context changed, an event~\emph{contextChanged()} is fired. This event can be
caught and handled, as it is shown on the line~\lstref{eventCC} in Fig.~\ref{fig:mm},
but it is not mandatory though. Context in this scope is considered as a constant,
whose name consists of two parts, joined by a dot: a name of a group and a name
of a context. Thus, in function \emph{BaseStationG.contextChanged()} we can use
a passed parameter \emph{con} to find out what context has been activated, as
shown on the line~\lstref{concheck}.

\subsection{Transition rules}\label{subsec:rules}

In ConesC every context transition implies several checking stages, which are displayed in
Fig.~\ref{fig:ad}, such as: possibility of the transition, dependencies check and conditions
check. The successful check allows to continue a transition, while the failure leads either to
the canceling of the transition or to activation of the \emph{error} context. The latter is generated
automatically unless declared in a \emph{context group} by using the key-word \emph{is error},
as shown in Fig.~\ref{fig:ccc} on line~\lstref{iserror}.

\putfigure{ caption=Activation diagram.,label=fig:ad}{
 \centering
 \includegraphics[width=\columnwidth]{pdf/activation_diagram}
}

In our scenario, which is displayed on a figure~\ref{fig:wtd}, within \emph{Activity} group a
transition from \emph{NotMoving} to \emph{Resting} is only possible, and it is checked
by the first conditional chose displayed on a figure~\ref{fig:ad}.
Since each transition is governed by a separate rule, it is declared in a context component as shown
on line~\lstref{transitions} in figure~\ref{fig:nmc}. Here key-word \emph{transitions}
indicates the contexts a transition can be performed to. An attempt to initiate
a transition to the context, which is not declared in a given active context, leads to an error context
activation, since this kind of transitions is not possible.

\putsnippet{
 caption=NotMoving context.,
 label=fig:nmc,
 boxname=boxnmc
}

Despite the application's  functionality is split into isolated pieces by \emph{context groups},
there may exist relations among them. For example, within the 
\emph{Health conditions} group a transition from \emph{Healthy} to \emph{Diseased} is only
make sense if an animal is \emph{Resting} or \emph{NotMoving}. These inter-group
relations are covered in our context-oriented language by context dependencies,
which are checked in the second conditional chose on a figure~\ref{fig:ad}. In
ConesC dependencies are declared as it is shown on the line~\lstref{dependence}
in Fig.~\ref{fig:cc}. In \emph{transitions} section a context name followed by a
key-word \emph{iff} and a full name of another context means that
the transition will only be executed if the latter context is active. Should the
rule with dependency be violated, a transition to an error context will be triggered.

The last conditional chose displayed on a figure~\ref{fig:ad} is used for soft rules, violation of
which does not affect the execution of a program. For example, context~\emph{Running} is
activated if the difference between two GPS readings is relatively large, but it may be due to noise.
To make sure false positives are avoided, developers may want to check
readings of an accelerometer. Another example includes an energy saving scenario,
when a programmer may want to activate~\emph{Reachable} context only if a battery is
in~\emph{Normal} state, as shown in Fig.~\ref{fig:wtd}.
Violation of mentioned rules is a common situation and should not lead to an error state.
To this end, ConesC provides a \emph{check()} command, sample implementation of which is
displayed on the line~\lstref{check} in Fig.~\ref{fig:irc}. It is not mandatory to implement this
command, but should it return \emph{FALSE}, an initiated context transition does not occur,
a context is not activated and a system remains in the previous state.
This approach allows one not to think about conditions a transition taking
place in, but foresee possible inconsistencies.

Other types of inter-group relations imply automatic triggering of context
transition. Considering \emph{Battery} group in our example, we can notice that
for further energy saving developers may want to trigger a transition to
\emph{Unreachable} context within the \emph{Base Station} group as long as
\emph{Low} context is active. Our design allows one to do that by declaring a
\emph{triggers} section, as shown on the line~\lstref{triggers} in Fig.~\ref{fig:lc}.
The same checks apply to automatic transitions.

\putsnippet{
 caption=Low context.,
 label=fig:lc,
 boxname=boxlc
}



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "bare_conf"
%%% End: 
