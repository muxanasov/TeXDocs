\section{Context Oriented nesC (ConesC)} 

The main benefit of ConesC is a possibility to alternate the behavior of a software at
run-time. It implies also a run-time errors catching and handling. Our approach
provides a deep modularization as well. Thus, behavioral variations are encapsulated
into different modules. The latter, as we show in section~\ref{sec:evalcomp},
are highly decoupled, which enhances code readability and re-usability as well as debugging
and developing processes. The behavioral variation can be achieved by calling a
layered function, since the contextual dependent logic is encapsulated by an isolated module, or
by catching and handling an error event, which can be invoked at run-time.

Programming in ConesC is tightly coupled with environment-dependent behavior of
the application and exploits two main concepts: \emph{i)} individual contexts
and their transitions and \emph{ii)} context groups. The former represent
different environment situations where a system may find itself. Each context
maps to a separate state of the device or environment a system operates in. As
the environment conditions change, a programmer initiates a context transition
by \emph{activating} the corresponding context. A context group is a set of contexts
sharing common characteristics. Thus, whenever a transition between involved
contexts occurs, it is determined by changes in one or more physical quantities.

\subsection{Application design}

The diagram on a figure~\ref{fig:wtd} shows how these concepts are used in application's design.
Depending on GPS readings developers may want to vary a sampling rate to use energy
more effective. For example, there is no need to
track a location if an animal is \emph{Not Moving}, but should accelerometer detect any
significant movement, a periodic sampling should be initiated. Increased
difference between two location readings indicates that an animal is
\emph{Running}, and location sampling should occurs more often.
Here contexts~\emph{Running}, \emph{Resting} and~\emph{Not Moving} are based on
a physical quantity -- the velocity of an animal -- and reflect
variations of the same functionality, such as GPS sampling with a given frequency,
so they can be joined into a group.

In social networks there exists a motion~\cite{pasztor10}, which can be exploited to
reduce energy consumption. For example, it makes no sense to send beacons
from the node, which is attached to the most active animal in a herd, i.e.~\emph{Leader},
since the node communicates with the most nodes in the network. Opposite to~\emph{Leader},
other nodes send beacons to reveal themselves.

Orthogonal to application-level functionality, the system should transmit data to
the Base Station (BS) or save readings locally depending on the BS
availability. While the BS is \emph{Out Range}, GPS-sensor is used to
obtain the location and data is written in internal memory. But should the node
receive a BS-beacon, the data is dumped to the BS and GPS-sensor is disabled
since the location of the is well-known BS. The application also should be aware
of battery status and disable power consuming modules like GPS and GPRS if the
battery level is \emph{Low}.

ConesC reflects this design by using new types of components, such as
\emph{context} and \emph{context group}, which are extensions of \emph{module} and
\emph{configuration} correspondingly, and a set of new key-words.
Instances of new types, however, can also be used as standard nesC components,
e.g. they can provide or use interfaces as well as be declared in the same way.

\begin{figure}[!h]
\centering
\includegraphics[width=\columnwidth]{pdf/wildlifetracking}
\caption{Wildlife tracking diagram.}
\label{fig:wtd}
\end{figure}

\subsection{Contexts and Context Groups}\label{subsec:components}

A \emph{Context group} component (figure~\ref{fig:ccc}) is used to declare layered
functions as well as the included contexts. Here the key-word \emph{layered}
(line~\lstref{layereddef}) means that the behavior of this function depends on
activated context. The declaration of contexts (line~\lstref{contexts}) follows a key-word
\emph{contexts}. It is mandatory, however, to declare \emph{default} context
(line~\lstref{isdefault}), which will be activated at the beginning of the execution,
by using key-word \emph{is default}. ConesC also supports a declaration of \emph{error}
(line~\lstref{iserror}) context for each group by the key-word \emph{is error}.
Error context is used to indicate and to handle errors occurred during the execution. If
error context is not declared, it will be generated automatically. We discuss the use of
this context in section~\ref{subsec:rules}.

\input{cc_snippet}
\begin{figure}[!h]
\TheSbox
\caption{Context configuration
component.}
\label{fig:ccc}
\end{figure}

\emph{Context} component (figures~\ref{fig:cc} and~\ref{fig:irc}) includes an
implementation of layered function (line~\lstref{layeredimp}) declared in context configuration. 
This approach enables a behavioral variation, since the implementation of a layered function is
context-specific, and only one context within the group can be active at a time. Thus, in our
example, a behavior of the function \emph{report()} depends on the activated context and
deposits a message in local memory while \emph{Out Range} context
is active (figure~\ref{fig:cc}, line~\lstref{layeredimp}),
or sends it directly to the BS otherwise (figure~\ref{fig:irc}, line~\lstref{layeredimp2}).
Programmer may want to add some instructions after
context activation such as initialization of variables or enabling/disabling
modules (in our example, enable GPS-sensor on entering in \emph{Out Range}
context). Or it may be necessary to reset component's state before context
deactivation. ConesC allows to do this by implementing events \emph{activated()} and
\emph{deactivated()} correspondingly (figure~\ref{fig:cc}, lines~\lstref{activated}
and~\lstref{deactivated}), it is not obligatory though.

\input{c_snippet}
\begin{figure}[!h]
\TheSbox
\caption{Context component.}
\label{fig:cc}
\end{figure}

\subsection{Transition rules}\label{subsec:rules}

In ConesC every context transition implies several checking stages (figure~\ref{fig:ad}) such as:
possibility of the transition, dependencies check and conditions check. The successful check allows
to continue a transition, while the failure leads to different states depending on the stage. In this
section we discuss and provide a usage examples for each of them. 

Negative outcomes of the first two conditional chooses (figure~\ref{fig:ad}) indicate
serious logical problems of a program. ConesC allows programmer to
handle these errors at run-time, by defining and implementing an error context. It will be activated,
if the context transition is not possible or dependencies are not satisfied. As it was mentioned in
the subsection~\ref{subsec:components}, an error context can be declared
in~\emph{context group} by using a key-word~\emph{is error}. It is not mandatory,
though, and it will be generated automatically anyway. Conditions check, however, can fail quite
often, since it depends on rapidly changing environment. If conditions are not
satisfied, context will not be activated and the system will remain in the same context. 

\begin{figure}[!h]
\centering
\includegraphics[width=\columnwidth]{pdf/activation_diagram}
\caption{Activation diagram.}
\label{fig:ad}
\end{figure}

In our scenario, which is displayed on a figure~\ref{fig:wtd}, within \emph{Activity} group a
transition from \emph{Not Moving} to \emph{Resting} is only possible, and it is checked
by the first conditional chose displayed on a figure~\ref{fig:ad}.
Since each transition is governed by a separate rule, it is declared in a context component as shown
on figure~\ref{fig:nmc} (line~\lstref{transitions}). Here key-word \emph{transitions} indicates the
contexts a transition can be performed to. An attempt to initiate
a transition to the context, which is not declared in a given active context, leads to an error context
activation, since this kind of transitions is not possible.

\input{nmc_snippet}
\begin{figure}[!h]
\TheSbox
\caption{NotMoving context.}
\label{fig:nmc}
\end{figure}

Despite the application's  functionality is split into isolated pieces by~\emph{context groups},
there may exist relations among them. For example, within the 
\emph{Base Station} group a transition from \emph{Out Range} to \emph{In Range} is only
make sense if an animal is \emph{Running}. These inter-group relations are covered in our
context-oriented language by context dependencies, which are checked in the second
conditional chose on a figure~\ref{fig:ad}. In ConesC dependencies are declared as it is shown on a
figure~\ref{fig:cc} (line~\lstref{dependence}). In \emph{transitions} section a context name
followed by a key-word \emph{iff} and a full name of another context means that
the transition will only be executed if the latter context is active. Should the rule with dependency
be violated, a transition to an error context will be triggered.

The last conditional chose displayed on a figure~\ref{fig:ad} is used for soft rules, violation of
which does not affect the execution of a program. For example, context~\emph{Running} is
activated if the difference between two GPS readings is relatively large, but it may be due to noise.
To make sure false positives are avoided, a programmer may want to check
readings of an accelerometer. Another example includes energy saving scenario,
thus a programmer may want to activate~\emph{In Range} context only if a battery is
in~\emph{Normal} state (figure~\ref{fig:wtd}).
Violation of mentioned rules is a common situation and should not lead to an error state.
To this end, ConesC provides a \emph{check()} command
(figure~\ref{fig:irc}, line~\lstref{check}). It is not mandatory to implement this command, but
should it return \emph{FALSE}, an initiated context transition does not occur,
a context is not activated and a system remains in the previous state.
This approach allows one not to think about conditions a transition taking
place in, but foresee possible inconsistencies.

\input{irc_snippet}
\begin{figure}[!h]
\TheSbox
\caption{InRange context.}
\label{fig:irc}
\end{figure}

Other types of inter-group relations imply automatic triggering of context
transition. Considering \emph{Battery} group in our example, we can notice that
for further energy saving programmer may want to trigger a transition to
\emph{Out Range} context within a \emph{Base Station} group as long as
\emph{Low} context is active. Our design allows one to do that by declaring a
\emph{triggers} section (Figure~\ref{fig:lc} line~\lstref{triggers}). The same checks apply to
automatic transitions.

\input{lc_snippet}
\begin{figure}[!h]
\TheSbox
\caption{Low context.}
\label{fig:lc}
\end{figure}

\subsection{Usage}

This section shows how ConesC can be used to invoke a behavioral
variation. Here we describe one aspect of an application's behavioral variation,
which is related to the Base Station availability. As it was mentioned before,
if a node receives a beacon from the Base Station it activates the~\emph{In Range}
context, and the~\emph{Out Range} context in case of timeout.
Since the behavioral variation is encapsulated in a context group~\emph{BaseStationG},
a programmer may not care about the context implementation, but should use a context group
to change a behavior of the application at run-time. In the main
configuration (figure~\ref{fig:mc}) the base station group is declared
(line~\lstref{declaration}) and wired (line~\lstref{wiring}) as a standard
component, since it is an extension of a configuration.

\input{mc_snippet}
\begin{figure}[!h]
\TheSbox
\caption{Main configuration.}
\label{fig:mc}
\end{figure}

In the main module (figure~\ref{fig:mm}) however it is necessary to declare
explicitly that we are using a context group \emph{BaseStationG}
(line~\lstref{cgdecl}). Activation of a context initiates by using a key-word
\emph{activate} which is followed by a full context name. Thus
\emph{InRange} context is activated on the line~\lstref{actBS} as soon as a
beacon from the base station is received. But should timeout occur, context
\emph{OutRange} will be activated (line~\lstref{actNoBS}). The benefit of
this approach is that layered function can be called independently
(line~\lstref{calling}), and activating code can be kept separately from function
calls, even in a separate module (figure~\ref{fig:bscm}).
Moreover one should not care about the base station availability, while
reporting measured data, since the behavior of layered function
\emph{BaseStationG.report()} depends on activated context, i.e. the base
station availability.

\input{mm_snippet}
\begin{figure}[!h]
\TheSbox
\caption{Main module.}
\label{fig:mm}
\end{figure}

\input{bscm_snippet}
\begin{figure}[!h]
\TheSbox
\caption{Base station context manager.}
\label{fig:bscm}
\end{figure}

Every time the context changed, an event~\emph{contextChanged()} is fired. This event can be
caught and handled, as it is shown on the line~\lstref{eventCC} (figure~\ref{fig:mm}),
but it is not mandatory though. Context in this scope is considered as a constant,
whose name consists of two parts, joined by a dot: a name of a group and a name
of a context. Thus, in function \emph{BaseStationG.contextChanged()} we can use
a passed parameter \emph{con} to find out what context has been activated, as
shown on line~\lstref{concheck}.
